{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { compare, hash } from 'bcrypt';\nimport { Service } from 'typedi';\nimport { SECRET_KEY } from '@config';\nimport { DB } from '@database';\nimport { CreateUserDto, LoginUserDto, GoogleLoginUserDto } from '@dtos/users.dto';\nimport { HttpException } from '@/exceptions/httpException';\nimport { DataStoredInToken, TokenData } from '@interfaces/auth.interface';\nimport { User } from '@interfaces/users.interface';\nimport jwt from 'jsonwebtoken';\nimport { SignInMethod } from '@/constants';\nimport { UserModel } from '@/models/user.model';\n\nexport const createToken = (user: User): TokenData => {\n  const dataStoredInToken: DataStoredInToken = { id: user.id };\n  const expiresIn: number = 60 * 60;\n  const token = jwt.sign(dataStoredInToken, SECRET_KEY, { expiresIn: expiresIn });\n  return {\n    expiresIn,\n    token: token,\n  };\n};\n\n@Service()\nexport class AuthService {\n  public async signup(userData: CreateUserDto): Promise<User> {\n    const findUser: User = await DB.Users.findOne({ where: { email: userData.email } });\n\n    if (findUser) {\n      throw new HttpException(409, `This email ${userData.email} already exists`);\n    }\n\n    const hashedPassword = await hash(userData.password, 10);\n    const createUserData: User = await DB.Users.create({ ...userData, password: hashedPassword, sign_in_method: SignInMethod.EMAIL });\n\n    return createUserData;\n  }\n\n  public async login(userData: LoginUserDto): Promise<{ tokenData: TokenData; findUser: User }> {\n    const findUser: User = await DB.Users.findOne({ where: { email: userData.email } });\n\n    if (!findUser) {\n      throw new HttpException(409, `This email was not found`);\n    }\n\n    if (findUser.sign_in_method !== SignInMethod.EMAIL) {\n      throw new HttpException(409, `This email was not registered via email and password.`);\n    }\n\n    const isPasswordMatching: boolean = await compare(userData.password, findUser.password);\n\n    if (!isPasswordMatching) {\n      throw new HttpException(409, 'Password not matching');\n    }\n\n    const tokenData = createToken(findUser);\n    // const cookie = createCookie(tokenData);\n\n    return { tokenData, findUser };\n  }\n\n  public async googleLogin(userData: GoogleLoginUserDto): Promise<{ tokenData: TokenData; findUser: User }> {\n    const { sub, name, picture, email } = userData;\n    const createUserData: { email: string; name: string; google_id: string; profile_image: string; sign_in_method: number } = {\n      email: email,\n      name: name,\n      google_id: sub,\n      profile_image: picture,\n      sign_in_method: SignInMethod.GOOGLE,\n    };\n\n    let user = await UserModel.findOne({\n      where: {\n        email: createUserData.email,\n      },\n    });\n\n    if (!user) {\n      user = await UserModel.create({ ...createUserData });\n    }\n\n    const findUser: User = await UserModel.findOne({ where: { email: createUserData.email } });\n\n    if (!findUser) {\n      throw new HttpException(409, `This email ${userData.email} was not found`);\n    }\n\n    const tokenData = createToken(findUser);\n\n    return { tokenData, findUser };\n  }\n\n  public async logout(userData: User): Promise<User> {\n    const findUser: User = await DB.Users.findOne({ where: { email: userData.email } });\n    if (!findUser) throw new HttpException(409, \"User doesn't exist\");\n\n    return findUser;\n  }\n}\n"],"names":["AuthService","createToken","user","dataStoredInToken","id","expiresIn","token","jwt","sign","SECRET_KEY","signup","userData","findUser","DB","Users","findOne","where","email","HttpException","hashedPassword","hash","password","createUserData","create","sign_in_method","SignInMethod","EMAIL","login","isPasswordMatching","compare","tokenData","googleLogin","sub","name","picture","google_id","profile_image","GOOGLE","UserModel","logout","Service"],"mappings":"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"}